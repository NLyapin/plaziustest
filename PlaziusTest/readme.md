# Сортировка маршрута

В проекте есть две реализации:
1. Метод GetTripPath. Память  O(2N), Complexety(2nlogn+n^2/2)
Общая идея. Делаем копию входной коллекции. Первую копию сортируем по to, вторую по from (2nlogn). Далее пробегаем по всем элементам
и если для одного из элементов из первого массива не нашли в соседнем соответсвия, то это хвост искомого пути.
Помещаем хвост в конец первого массива и начинаем вложенным циклом его заполнять (n^2/2).

2. Метод GetTripPathFast. Память  O(3N), Complexety(3n)
Общая идея. Заводим две хештаблицы. Одна для from, вторая для to. Заполняем их O(n).
Ищем хвост - бежим по элементам массива и смотрим такой to, который не встречается в from. O(n)
Помещаем хвост в конец и начинаем заполнять, используя хеш таблицу O(n)
